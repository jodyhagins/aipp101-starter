#ifndef WJH_CHAT_2BBE157ECC3AF8D3C5642A1483D04FDCCC560ACB
#define WJH_CHAT_2BBE157ECC3AF8D3C5642A1483D04FDCCC560ACB

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v1.0.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <concepts>
#include <cstdint>
#include <format>
#include <functional>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::undress(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
#include <format>
#endif

namespace atlas {

template<typename T>
struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value_for();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Enum case: T is an enum - convert to underlying type
// Always returns by value since conversion creates a distinct value.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_ref)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_val)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_for() hidden friend
// Use ADL to call atlas_value_for() and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(std::move(t)),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(std::move(t)), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_val{});
}

struct ToUnderlying
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

// ----------------------------------------------------------------------------
// Unwrap: Remove exactly one layer from atlas types or enums
// Unlike undress, this does NOT recurse.
// ----------------------------------------------------------------------------

template <typename T>
constexpr auto
unwrap_impl(T & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T const & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T && t, PriorityTag<2>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(atlas_value_for(std::move(t)))>::type
{
    return atlas_value_for(std::move(t));
}

// Enum fallback - convert to underlying type
template <typename T>
constexpr auto
unwrap_impl(T t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// No PriorityTag<0> - SFINAE failure for non-atlas/non-enum types

struct Unwrap
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(unwrap_impl(std::forward<T>(t), PriorityTag<2>{}))
    {
        return unwrap_impl(std::forward<T>(t), PriorityTag<2>{});
    }
};

// ----------------------------------------------------------------------------
// UndressEnum: Drill through atlas types and stop at enum
// Like undress, but stops at enum instead of converting to underlying type.
// SFINAE fails if the drill does not resolve to an enum.
// ----------------------------------------------------------------------------
using undress_enum_tag = PriorityTag<1>;

// Base case: T is an enum - return it (don't convert to underlying)
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T &>::type
{
    return t;
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T const &>::type
{
    return t;
}

// Base case: rvalue enum - return by value (avoids dangling reference)
template <typename T>
constexpr auto
undress_enum_impl(T && t, PriorityTag<0>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value && std::is_enum<T>::value,
    T>::type
{
    return t;
}

// Recursive case: drill through atlas types
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T && t, PriorityTag<1>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{}))>::type
{
    return undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{});
}

struct UndressEnum
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(undress_enum_impl(std::forward<T>(t), undress_enum_tag{}))
    {
        return undress_enum_impl(std::forward<T>(t), undress_enum_tag{});
    }
};

// ----------------------------------------------------------------------------
// Type trait: holds_enum - true if undress_enum would succeed
// Uses the same mechanism as undress_enum to ensure consistency.
// ----------------------------------------------------------------------------
template <typename T, typename = void>
struct holds_enum_impl : std::false_type {};

template <typename T>
struct holds_enum_impl<
    T,
    void_t<decltype(undress_enum_impl(
        std::declval<remove_cvref_t<T> &>(),
        undress_enum_tag{}))>>
: std::true_type {};

using cast_tag = PriorityTag<1>;

// ----------------------------------------------------------------------------
// cast_impl: Drill down to find the first type castable to TargetT
// ----------------------------------------------------------------------------
template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<1>)
-> decltype(static_cast<TargetT>(std::forward<U>(u)))
{
    return static_cast<TargetT>(std::forward<U>(u));
}

template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<0>)
-> decltype(cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{}))
{
    return cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{});
}

template <typename TargetT>
struct CastTo
{
    template <typename U>
    constexpr auto
    operator () (U && u) const
    -> decltype(cast_impl<TargetT>(std::forward<U>(u), cast_tag{}))
    {
        return cast_impl<TargetT>(std::forward<U>(u), cast_tag{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

template <typename T>
using holds_enum = atlas_detail::holds_enum_impl<atlas_detail::remove_cvref_t<T>>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;

template <typename T>
concept HoldsEnumC = holds_enum<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress = atlas_detail::ToUnderlying{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress = atlas_detail::ToUnderlying{};
#else
// fallback: not nice, but not terrible and prevents ADL
namespace {
constexpr atlas_detail::ToUnderlying undress{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto unwrap = atlas_detail::Unwrap{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto unwrap = atlas_detail::Unwrap{};
#else
namespace {
constexpr atlas_detail::Unwrap unwrap{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress_enum = atlas_detail::UndressEnum{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress_enum = atlas_detail::UndressEnum{};
#else
namespace {
constexpr atlas_detail::UndressEnum undress_enum{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
template <typename TargetT>
inline constexpr atlas_detail::CastTo<TargetT> cast{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
template <typename TargetT>
constexpr atlas_detail::CastTo<TargetT> cast{};
#else
// fallback: function template (ADL still possible, but unavoidable in C++11)
template <typename TargetT, typename U>
constexpr auto
cast(U && u)
-> decltype(atlas_detail::cast_impl<TargetT>(
    std::forward<U>(u),
    atlas_detail::cast_tag{}))
{
    return atlas_detail::cast_impl<TargetT>(
        std::forward<U>(u),
        atlas_detail::cast_tag{});
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

#ifndef WJH_ATLAS_771333B44A11491895F986933BB2FB41
#define WJH_ATLAS_771333B44A11491895F986933BB2FB41
namespace atlas {
namespace atlas_detail {
// ----------------------------------------------------------------------------
// Hash drilling support
// ----------------------------------------------------------------------------

// is_hashable<T>: detects if std::hash<T> is valid
template <typename T, typename = void>
struct is_hashable
: std::false_type
{ };

template <typename T>
struct is_hashable<
    T,
    void_t<decltype(std::hash<T>{}(std::declval<T const &>()))>>
: std::true_type
{ };

// Base case: T is directly hashable
template <typename T>
auto hash_drill(T const & t, PriorityTag<2>)
-> typename std::enable_if<
    is_hashable<T>::value,
    std::size_t>::type
{
    return std::hash<T>{}(t);
}

// Enum fallback: T is an enum without std::hash, use underlying type
template <typename T>
auto hash_drill(T const & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_hashable<T>::value,
    std::size_t>::type
{
    return std::hash<typename std::underlying_type<T>::type>{}(
        static_cast<typename std::underlying_type<T>::type>(t));
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto hash_drill(T const & t, PriorityTag<0>)
-> decltype(hash_drill(atlas_value_for(t), PriorityTag<2>{}))
{
    return hash_drill(atlas_value_for(t), PriorityTag<2>{});
}
} // namespace atlas_detail
} // namespace atlas
#endif // WJH_ATLAS_771333B44A11491895F986933BB2FB41

#ifndef WJH_ATLAS_60461ED5AEEF4509B86FB80C8B1E0FE0
#define WJH_ATLAS_60461ED5AEEF4509B86FB80C8B1E0FE0
namespace atlas {
namespace atlas_detail {
// ----------------------------------------------------------------------------
// OStream drilling support
// ----------------------------------------------------------------------------

// is_ostreamable<T>: detects if T can be written to std::ostream
template <typename T, typename = void>
struct is_ostreamable
: std::false_type
{ };

template <typename T>
struct is_ostreamable<
    T,
    void_t<decltype(std::declval<std::ostream &>() << std::declval<T const &>())>>
: std::true_type
{ };

// Base case: T is directly ostreamable
template <typename T>
auto ostream_drill(std::ostream & strm, T const & t, PriorityTag<2>)
-> typename std::enable_if<
    is_ostreamable<T>::value,
    std::ostream &>::type
{
    return strm << t;
}

// Enum fallback: T is an enum without operator<<, use underlying type
template <typename T>
auto ostream_drill(std::ostream & strm, T const & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_ostreamable<T>::value,
    std::ostream &>::type
{
    return strm << static_cast<typename std::underlying_type<T>::type>(t);
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto ostream_drill(std::ostream & strm, T const & t, PriorityTag<0>)
-> decltype(ostream_drill(strm, atlas_value_for(t), PriorityTag<2>{}))
{
    return ostream_drill(strm, atlas_value_for(t), PriorityTag<2>{});
}
} // namespace atlas_detail
} // namespace atlas
#endif // WJH_ATLAS_60461ED5AEEF4509B86FB80C8B1E0FE0

#ifndef WJH_ATLAS_4296E303C8F846C0B958EB450C57465B
#define WJH_ATLAS_4296E303C8F846C0B958EB450C57465B
namespace atlas {
namespace atlas_detail {
// ----------------------------------------------------------------------------
// IStream drilling support
// ----------------------------------------------------------------------------

// is_istreamable<T>: detects if T can be read from std::istream
template <typename T, typename = void>
struct is_istreamable
: std::false_type
{ };

template <typename T>
struct is_istreamable<
    T,
    void_t<decltype(std::declval<std::istream &>() >> std::declval<T &>())>>
: std::true_type
{ };

// Base case: T is directly istreamable
template <typename T>
auto istream_drill(std::istream & strm, T & t, PriorityTag<2>)
-> typename std::enable_if<
    is_istreamable<T>::value,
    std::istream &>::type
{
    return strm >> t;
}

// Enum fallback: T is an enum without operator>>, read as underlying type
template <typename T>
auto istream_drill(std::istream & strm, T & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_istreamable<T>::value,
    std::istream &>::type
{
    typename std::underlying_type<T>::type tmp;
    strm >> tmp;
    t = static_cast<T>(tmp);
    return strm;
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto istream_drill(std::istream & strm, T & t, PriorityTag<0>)
-> decltype(istream_drill(strm, atlas_value_for(t), PriorityTag<2>{}))
{
    return istream_drill(strm, atlas_value_for(t), PriorityTag<2>{});
}
} // namespace atlas_detail
} // namespace atlas
#endif // WJH_ATLAS_4296E303C8F846C0B958EB450C57465B

#ifndef WJH_ATLAS_9B74AE244B4F4EB68DF9D80B67E1EB05
#define WJH_ATLAS_9B74AE244B4F4EB68DF9D80B67E1EB05
namespace atlas {
namespace atlas_detail {
// ----------------------------------------------------------------------------
// Format drilling support (C++20+)
// ----------------------------------------------------------------------------
#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L

// Concept: T is formattable via std::formatter<T>
template <typename T>
concept formattable = requires(
    std::formatter<T> f,
    T const & t,
    std::format_parse_context & parse_ctx,
    std::format_context & fmt_ctx)
{
    f.parse(parse_ctx);
    f.format(t, fmt_ctx);
};

// Drill to find a formattable type, returning a reference or converted value
template <typename T>
constexpr decltype(auto) format_value_drill(T const & t)
{
    if constexpr (formattable<T>) {
        // Base case: T is directly formattable - return reference
        return (t);
    } else if constexpr (std::is_enum_v<T>) {
        // Enum fallback: convert to underlying type
        return static_cast<std::underlying_type_t<T>>(t);
    } else if constexpr (has_atlas_value_type<T>::value) {
        // Recursive case: drill through atlas type
        return format_value_drill(atlas_value_for(t));
    } else {
        static_assert(formattable<T>, "Type is not formattable after drilling");
    }
}

// Type trait for the drilled type
template <typename T>
using format_drilled_type_t =
    std::remove_cvref_t<decltype(format_value_drill(std::declval<T const &>()))>;

#endif // __cpp_lib_format
} // namespace atlas_detail
} // namespace atlas
#endif // WJH_ATLAS_9B74AE244B4F4EB68DF9D80B67E1EB05

#ifndef WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829
#define WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829

#include <sstream>

#ifdef __clang__
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wweak-vtables"
#endif

namespace atlas {

/**
 * @brief Exception thrown when a constraint is violated
 */
class ConstraintError
: public std::logic_error
{
public:
    using std::logic_error::logic_error;
};

namespace constraints {

namespace detail {

template <typename T>
std::string
format_value_impl(T const &, atlas_detail::PriorityTag<0>)
{
    return "unknown value";
}

template <typename T>
auto
format_value_impl(T const & value, atlas_detail::PriorityTag<1>)
-> decltype(std::declval<std::ostringstream &>() << value, std::string())
{
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

template <typename T, atlas_detail::when<std::is_arithmetic<T>::value> = true>
std::string
format_value_impl(T const & value, atlas_detail::PriorityTag<2>)
{
    using U = typename std::conditional<
        std::is_integral<T>::value && sizeof(T) < sizeof(int),
        typename std::conditional<
            std::is_unsigned<T>::value,
            unsigned int,
            signed int>::type,
        T>::type;
    return std::to_string(static_cast<U>(value));
}

template <typename T>
std::string
format_value(T const & value)
{
    return format_value_impl(value, atlas_detail::PriorityTag<2>{});
}

inline int uncaught_exceptions() noexcept
{
#if defined(__cpp_lib_uncaught_exceptions) && \
    __cpp_lib_uncaught_exceptions >= 201411L
    return std::uncaught_exceptions();
#elif defined(_MSC_VER)
    return __uncaught_exceptions();  // MSVC extension available since VS2015
#elif defined(__GLIBCXX__)
    // libstdc++ has __cxa_get_globals which tracks uncaught exceptions
    return __cxxabiv1::__cxa_get_globals()->uncaughtExceptions;
#elif defined(_LIBCPP_VERSION)
    // libc++ has std::uncaught_exceptions even in C++11 mode as extension
    return std::uncaught_exceptions();
#else
    // Fallback: use old uncaught_exception() (singular) - less safe but works
    // This will return 1 during any exception, 0 otherwise
    // Can't distinguish between multiple exceptions, but better than nothing
    return std::uncaught_exception() ? 1 : 0;
#endif
}

/**
 * @brief RAII guard for validating constraints after mutating operations
 *
 * This guard validates constraints in its destructor, ensuring that the
 * constraint is checked after the operation completes. The guard checks
 * uncaught_exceptions() to avoid throwing during stack unwinding.
 *
 * Only validates non-const operations - const operations cannot violate
 * constraints by definition.
 *
 * @tparam T The value type being constrained (may be const)
 * @tparam ConstraintT The constraint type with static check() and message()
 */
template <typename T, typename ConstraintT, typename = void>
struct ConstraintGuard
{
    using value_type = typename std::remove_const<T>::type;

    T const & value;
    char const * operation_name;
    int uncaught_at_entry;

    /**
     * @brief Construct guard, capturing current exception state
     */
    constexpr ConstraintGuard(T const & v, char const * op) noexcept
    : value(v)
    , operation_name(op)
    , uncaught_at_entry(uncaught_exceptions())
    { }

    /**
     * @brief Destructor validates constraint if no new exceptions
     *
     * Only throws if the constraint is violated AND no exceptions are
     * currently unwinding (to avoid std::terminate).
     *
     * Only validates non-const operations - uses std::is_const to check.
     */
    constexpr ~ConstraintGuard() noexcept(false)
    {
        if (uncaught_exceptions() == uncaught_at_entry) {
            if (not ConstraintT::check(value)) {
                throw atlas::ConstraintError(
                    std::string(operation_name) +
                    ": operation violates constraint (" +
                    ConstraintT::message() + ")");
            }
        }
    }
};

template <typename T, typename ConstraintT>
struct ConstraintGuard<
    T,
    ConstraintT,
    typename std::enable_if<std::is_const<T>::value>::type>
{
    constexpr ConstraintGuard(T const &, char const *) noexcept
    { }
};

} // namespace detail

template <typename ConstraintT, typename T>
auto constraint_guard(T & t, char const * op) noexcept
{
    return detail::ConstraintGuard<T, ConstraintT>(t, op);
}

template <typename T>
constexpr auto is_nil_value(typename T::atlas_value_type const * value)
-> decltype(atlas::undress(T::nil_value) == *value)
{
    return atlas::undress(T::nil_value) == *value;
}

template <typename T>
constexpr bool is_nil_value(void const *)
{
    return false;
}

template <typename T>
constexpr bool check(typename T::atlas_value_type const & value)
{
    return is_nil_value<T>(std::addressof(value)) ||
        T::atlas_constraint::check(value);
}

/**
 * @brief Constraint: value must be > 0
 */
template <typename T>
struct positive
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value > T{0}))
    {
        return value > T{0};
    }

    static constexpr char const * message() noexcept
    {
        return "value must be positive (> 0)";
    }
};

/**
 * @brief Constraint: value must be >= 0
 */
template <typename T>
struct non_negative
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value >= T{0}))
    {
        return value >= T{0};
    }

    static constexpr char const * message() noexcept
    {
        return "value must be non-negative (>= 0)";
    }
};

/**
 * @brief Constraint: value must be != 0
 */
template <typename T>
struct non_zero
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value != T{0}))
    {
        return value != T{0};
    }

    static constexpr char const * message() noexcept
    {
        return "value must be non-zero (!= 0)";
    }
};

/**
 * Constraint: value must be in [Min, Max]
 */
template <typename T>
struct bounded
{
    static constexpr bool check(typename T::value_type const & value)
    noexcept(noexcept(value >= T::min()) && noexcept(value <= T::max()))
    {
        return value >= T::min() && value <= T::max();
    }

    static constexpr char const * message() noexcept
    {
        return T::message();
    }
};

/**
 * Constraint: value must be in [Min, Max) (half-open range)
 */
template <typename T>
struct bounded_range
{
    static constexpr bool check(typename T::value_type const & value)
    noexcept(noexcept(value >= T::min()) && noexcept(value < T::max()))
    {
        return value >= T::min() && value < T::max();
    }

    static constexpr char const * message() noexcept
    {
        return T::message();
    }
};

/**
 * @brief Constraint: container/string must not be empty
 */
template <typename T>
struct non_empty
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value.empty()))
    {
        return not value.empty();
    }

    static constexpr char const * message() noexcept
    {
        return "value must not be empty";
    }
};

/**
 * @brief Constraint: pointer must not be null
 *
 * Works with raw pointers, smart pointers (unique_ptr, shared_ptr), and
 * std::optional by using explicit bool conversion (operator bool()).
 *
 * Note: weak_ptr requires C++23 for operator bool() support.
 */
template <typename T>
struct non_null
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(static_cast<bool>(value)))
    {
        // Use explicit bool conversion - works for:
        // - Raw pointers (void*, int*, etc.)
        // - Smart pointers (unique_ptr, shared_ptr)
        // - std::optional
        // - Any type with explicit operator bool()
        return static_cast<bool>(value);
    }

    static constexpr char const * message() noexcept
    {
        return "pointer must not be null";
    }
};

} // namespace constraints
} // namespace atlas

#ifdef __clang__
    #pragma clang diagnostic pop
#endif

#endif // WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829

#ifndef WJH_ATLAS_83B11BF12B6945019DF71C7517A1D6DA
#define WJH_ATLAS_83B11BF12B6945019DF71C7517A1D6DA
#if __cplusplus >= 202002L
namespace atlas::atlas_detail {

// Concept: T is an atlas type whose underlying value chain is eventually
// hashable
template <typename T>
concept atlas_hashable = has_atlas_value_type<T>::value &&
    requires(T const & t) {
        { hash_drill(atlas_value_for(t), PriorityTag<2>{}) }
            -> std::same_as<std::size_t>;
    };

} // namespace atlas::atlas_detail

template <typename T>
    requires atlas::atlas_detail::atlas_hashable<T>
struct std::hash<T>
{
    std::size_t operator()(T const & t) const
    noexcept(noexcept(atlas::atlas_detail::hash_drill(
        atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{})))
    {
        return atlas::atlas_detail::hash_drill(
            atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{});
    }
};
#endif // C++20
#endif // WJH_ATLAS_83B11BF12B6945019DF71C7517A1D6DA

#ifndef WJH_ATLAS_A3A2ADA707CA47BE9EB94254C729C906
#define WJH_ATLAS_A3A2ADA707CA47BE9EB94254C729C906
#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
namespace atlas::atlas_detail {

// Concept: T is an atlas type whose underlying value chain is eventually
// formattable
template <typename T>
concept atlas_formattable = has_atlas_value_type<T>::value &&
    requires(T const & t) {
        format_value_drill(atlas_value_for(t));
    };

} // namespace atlas::atlas_detail

template <typename T>
    requires atlas::atlas_detail::atlas_formattable<T>
struct std::formatter<T>
{
private:
    using drilled_type_ =
        atlas::atlas_detail::format_drilled_type_t<typename T::atlas_value_type>;
    std::formatter<drilled_type_> underlying_formatter_;

public:
    constexpr auto parse(std::format_parse_context & ctx)
    {
        return underlying_formatter_.parse(ctx);
    }

    auto format(T const & t, std::format_context & ctx) const
    {
        return underlying_formatter_.format(
            atlas::atlas_detail::format_value_drill(atlas_value_for(t)),
            ctx);
    }
};
#endif // __cpp_lib_format
#endif // WJH_ATLAS_A3A2ADA707CA47BE9EB94254C729C906

#ifndef WJH_ATLAS_204DEDF8AD1A4B8EA2910C659C4523BC
#define WJH_ATLAS_204DEDF8AD1A4B8EA2910C659C4523BC
namespace atlas {

// Templated operator<< for all atlas types
// ADL finds this via atlas::strong_type_tag base class
template <typename T>
auto operator<<(std::ostream & strm, T const & t)
-> typename std::enable_if<
    atlas_detail::has_atlas_value_type<T>::value,
    decltype(atlas_detail::ostream_drill(
        strm, atlas_value_for(t), atlas_detail::PriorityTag<2>{}))>::type
{
    return atlas_detail::ostream_drill(
        strm, atlas_value_for(t), atlas_detail::PriorityTag<2>{});
}

} // namespace atlas
#endif // WJH_ATLAS_204DEDF8AD1A4B8EA2910C659C4523BC

#ifndef WJH_ATLAS_8E1585765002403FBFA3B92531F0A25E
#define WJH_ATLAS_8E1585765002403FBFA3B92531F0A25E
namespace atlas {

// Templated operator>> for all atlas types
// ADL finds this via atlas::strong_type_tag base class
template <typename T>
auto operator>>(std::istream & strm, T & t)
-> typename std::enable_if<
    atlas_detail::has_atlas_value_type<T>::value,
    decltype(atlas_detail::istream_drill(
        strm, atlas_value_for(t), atlas_detail::PriorityTag<2>{}))>::type
{
    return atlas_detail::istream_drill(
        strm, atlas_value_for(t), atlas_detail::PriorityTag<2>{});
}

} // namespace atlas
#endif // WJH_ATLAS_8E1585765002403FBFA3B92531F0A25E


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: ApiKey
 * - description: std::string; <=>, non_empty
 * - default_value: ""
 */
class ApiKey
: private atlas::strong_type_tag<ApiKey>
{
    std::string value;

public:
    using atlas_value_type = std::string;
    using atlas_constraint = atlas::constraints::non_empty<std::string>;

    ApiKey() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ApiKey(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<ApiKey>(value)) {
            throw atlas::ConstraintError(
                "ApiKey: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: value must not be empty");
        }
    }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(ApiKey const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(ApiKey & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ApiKey && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward substr to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     *
     * IMPORTANT: Constraint checking occurs AFTER the operation executes.
     * This is an inherent limitation of generic constraint checking - we cannot
     * know ahead of time if an operation will violate a constraint without
     * operation-specific knowledge.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substr(this Self&& self, Args&&... args)
    -> decltype(std::forward<Self>(self).value.substr(std::forward<Args>(args)...))
    {
        using atlas::constraints::constraint_guard;
        [[maybe_unused]] auto guard = constraint_guard<atlas_constraint>(
            self.value,
            "ApiKey::substr");
        return std::forward<Self>(self).value.substr(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &
    noexcept(noexcept(value.substr(std::forward<Args>(args)...)))
    -> decltype(value.substr(std::forward<Args>(args)...))
    {
        return value.substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &&
    noexcept(noexcept(std::move(value).substr(std::forward<Args>(args)...)))
    -> decltype(std::move(value).substr(std::forward<Args>(args)...))
    {
        return std::move(value).substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &
    -> decltype(value.substr(std::forward<Args>(args)...))
    {
        using atlas::constraints::constraint_guard;
        [[maybe_unused]] auto guard = constraint_guard<atlas_constraint>(
            value,
            "ApiKey::substr");
        return value.substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &&
    -> decltype(std::move(value).substr(std::forward<Args>(args)...))
    {
        using atlas::constraints::constraint_guard;
        [[maybe_unused]] auto guard = constraint_guard<atlas_constraint>(
            value,
            "ApiKey::substr");
        return std::move(value).substr(std::forward<Args>(args)...);
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        ApiKey const &,
        ApiKey const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        ApiKey const & lhs,
        ApiKey const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        ApiKey const & lhs,
        ApiKey const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        ApiKey const & lhs,
        ApiKey const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        ApiKey const & lhs,
        ApiKey const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        ApiKey const &,
        ApiKey const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        ApiKey const & lhs,
        ApiKey const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        ApiKey const & lhs,
        ApiKey const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: ModelId
 * - description: std::string; <=>, non_empty
 * - default_value: ""anthropic/claude-sonnet-4""
 */
class ModelId
: private atlas::strong_type_tag<ModelId>
{
    std::string value = static_cast<std::string>("anthropic/claude-sonnet-4");

public:
    using atlas_value_type = std::string;
    using atlas_constraint = atlas::constraints::non_empty<std::string>;

    ModelId() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ModelId(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<ModelId>(value)) {
            throw atlas::ConstraintError(
                "ModelId: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: value must not be empty");
        }
    }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(ModelId const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(ModelId & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ModelId && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        ModelId const &,
        ModelId const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        ModelId const & lhs,
        ModelId const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        ModelId const & lhs,
        ModelId const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        ModelId const & lhs,
        ModelId const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        ModelId const & lhs,
        ModelId const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        ModelId const &,
        ModelId const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        ModelId const & lhs,
        ModelId const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        ModelId const & lhs,
        ModelId const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::uint32_t
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: MaxTokens
 * - description: std::uint32_t; <=>, positive
 * - default_value: "4096u"
 */
class MaxTokens
: private atlas::strong_type_tag<MaxTokens>
{
    std::uint32_t value = static_cast<std::uint32_t>(4096u);

public:
    using atlas_value_type = std::uint32_t;
    using atlas_constraint = atlas::constraints::positive<std::uint32_t>;

    constexpr explicit MaxTokens() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::uint32_t, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit MaxTokens(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<MaxTokens>(value)) {
            throw atlas::ConstraintError(
                "MaxTokens: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: value must be positive (> 0)");
        }
    }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::uint32_t const & atlas_value_for(MaxTokens const & self) noexcept {
        return self.value;
    }
    friend constexpr std::uint32_t & atlas_value_for(MaxTokens & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(MaxTokens && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::uint32_t>::value,
            std::uint32_t>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        MaxTokens const &,
        MaxTokens const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        MaxTokens const & lhs,
        MaxTokens const & rhs)
    noexcept(noexcept(std::declval<std::uint32_t const &>() <
        std::declval<std::uint32_t const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        MaxTokens const & lhs,
        MaxTokens const & rhs)
    noexcept(noexcept(std::declval<std::uint32_t const &>() <=
        std::declval<std::uint32_t const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        MaxTokens const & lhs,
        MaxTokens const & rhs)
    noexcept(noexcept(std::declval<std::uint32_t const &>() >
        std::declval<std::uint32_t const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        MaxTokens const & lhs,
        MaxTokens const & rhs)
    noexcept(noexcept(std::declval<std::uint32_t const &>() >=
        std::declval<std::uint32_t const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        MaxTokens const &,
        MaxTokens const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        MaxTokens const & lhs,
        MaxTokens const & rhs)
    noexcept(noexcept(std::declval<std::uint32_t const &>() ==
        std::declval<std::uint32_t const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        MaxTokens const & lhs,
        MaxTokens const & rhs)
    noexcept(noexcept(std::declval<std::uint32_t const &>() !=
        std::declval<std::uint32_t const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: SystemPrompt
 * - description: std::string; <=>
 * - default_value: ""
 */
class SystemPrompt
: private atlas::strong_type_tag<SystemPrompt>
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit SystemPrompt() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit SystemPrompt(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(SystemPrompt const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(SystemPrompt & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(SystemPrompt && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        SystemPrompt const &,
        SystemPrompt const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        SystemPrompt const & lhs,
        SystemPrompt const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        SystemPrompt const & lhs,
        SystemPrompt const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        SystemPrompt const & lhs,
        SystemPrompt const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        SystemPrompt const & lhs,
        SystemPrompt const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        SystemPrompt const &,
        SystemPrompt const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        SystemPrompt const & lhs,
        SystemPrompt const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        SystemPrompt const & lhs,
        SystemPrompt const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for bool
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: ShowHelp
 * - description: bool; ==, bool
 * - default_value: "false"
 */
class ShowHelp
: private atlas::strong_type_tag<ShowHelp>
{
    bool value = static_cast<bool>(false);

public:
    using atlas_value_type = bool;

    constexpr explicit ShowHelp() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<bool, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ShowHelp(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr bool const & atlas_value_for(ShowHelp const & self) noexcept {
        return self.value;
    }
    friend constexpr bool & atlas_value_for(ShowHelp & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ShowHelp && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<bool>::value,
            bool>::type
    {
        return std::move(self.value);
    }

    /**
     * Return the result of casting the wrapped object to bool.
     */
    constexpr explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<bool const&>())))
    {
        return static_cast<bool>(value);
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ShowHelp const & lhs,
        ShowHelp const & rhs)
    noexcept(noexcept(std::declval<bool const&>() == std::declval<bool const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for bool
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: ShowConfig
 * - description: bool; ==, bool
 * - default_value: "false"
 */
class ShowConfig
: private atlas::strong_type_tag<ShowConfig>
{
    bool value = static_cast<bool>(false);

public:
    using atlas_value_type = bool;

    constexpr explicit ShowConfig() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<bool, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ShowConfig(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr bool const & atlas_value_for(ShowConfig const & self) noexcept {
        return self.value;
    }
    friend constexpr bool & atlas_value_for(ShowConfig & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ShowConfig && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<bool>::value,
            bool>::type
    {
        return std::move(self.value);
    }

    /**
     * Return the result of casting the wrapped object to bool.
     */
    constexpr explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<bool const&>())))
    {
        return static_cast<bool>(value);
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ShowConfig const & lhs,
        ShowConfig const & rhs)
    noexcept(noexcept(std::declval<bool const&>() == std::declval<bool const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: ProgramName
 * - description: std::string; <=>
 * - default_value: ""
 */
class ProgramName
: private atlas::strong_type_tag<ProgramName>
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit ProgramName() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ProgramName(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(ProgramName const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(ProgramName & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ProgramName && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        ProgramName const &,
        ProgramName const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        ProgramName const & lhs,
        ProgramName const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        ProgramName const & lhs,
        ProgramName const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        ProgramName const & lhs,
        ProgramName const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        ProgramName const & lhs,
        ProgramName const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        ProgramName const &,
        ProgramName const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        ProgramName const & lhs,
        ProgramName const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        ProgramName const & lhs,
        ProgramName const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: HelpText
 * - description: std::string; <=>
 * - default_value: ""
 */
class HelpText
: private atlas::strong_type_tag<HelpText>
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit HelpText() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit HelpText(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(HelpText const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(HelpText & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(HelpText && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        HelpText const &,
        HelpText const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        HelpText const & lhs,
        HelpText const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        HelpText const & lhs,
        HelpText const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        HelpText const & lhs,
        HelpText const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        HelpText const & lhs,
        HelpText const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        HelpText const &,
        HelpText const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        HelpText const & lhs,
        HelpText const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        HelpText const & lhs,
        HelpText const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: UserInput
 * - description: std::string; <=>
 * - default_value: ""
 */
class UserInput
: private atlas::strong_type_tag<UserInput>
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit UserInput() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit UserInput(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(UserInput const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(UserInput & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(UserInput && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        UserInput const &,
        UserInput const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        UserInput const & lhs,
        UserInput const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        UserInput const & lhs,
        UserInput const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        UserInput const & lhs,
        UserInput const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        UserInput const & lhs,
        UserInput const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        UserInput const &,
        UserInput const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        UserInput const & lhs,
        UserInput const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        UserInput const & lhs,
        UserInput const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh


namespace wjh {
namespace chat {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: wjh::chat
 * - type_name: AssistantResponse
 * - description: std::string; <=>
 * - default_value: ""
 */
class AssistantResponse
: private atlas::strong_type_tag<AssistantResponse>
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit AssistantResponse() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit AssistantResponse(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(AssistantResponse const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(AssistantResponse & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(AssistantResponse && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        AssistantResponse const &,
        AssistantResponse const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        AssistantResponse const & lhs,
        AssistantResponse const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        AssistantResponse const & lhs,
        AssistantResponse const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        AssistantResponse const & lhs,
        AssistantResponse const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        AssistantResponse const & lhs,
        AssistantResponse const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        AssistantResponse const &,
        AssistantResponse const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        AssistantResponse const & lhs,
        AssistantResponse const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        AssistantResponse const & lhs,
        AssistantResponse const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace chat
} // namespace wjh

#endif // WJH_CHAT_2BBE157ECC3AF8D3C5642A1483D04FDCCC560ACB
